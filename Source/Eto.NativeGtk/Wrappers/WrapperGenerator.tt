﻿<#@ template hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#

var wdata = new List<WrapperData>();
wdata.Add(new WrapperData { Library = "libgtk-3.so.0", Name = "GtkWrapper", File = "GtkWrapperData.cs" });
wdata.Add(new WrapperData { Library = "libgtk-3.so.0", Name = "GioWrapper", File = "GioWrapperData.cs" });

#>
using System;
using System.Runtime.InteropServices;
using System.Text;

static class WrapperHelper
{
    public static string GetString(IntPtr ptr)
    {
        if (ptr == IntPtr.Zero)
            return "";

        int len = 0;
        while (Marshal.ReadByte(ptr, len) != 0)
            len++;

        var bytes = new byte[len];
        Marshal.Copy(ptr, bytes, 0, bytes.Length);

        return Encoding.UTF8.GetString(bytes);
    }
}

<#
foreach (var data in wdata)
{
#>

static partial class <#= data.Name #>
{
    public const string NativeLib = "<#= data.Library #>";

<#
    var lines = File.ReadAllLines(Path.Combine(Path.GetDirectoryName(this.Host.TemplateFile), data.File));
	var methods = new List<Method>();

	foreach(var line in lines)
	{
	    if (string.IsNullOrEmpty(line) || line.Contains("//"))
	        continue;

	    methods.Add(new Method(line));
	}

	foreach (var method in methods)
	{
	#><#=method #><#
	}
#>}<#
}
#>
<#+
public class WrapperData
{
    public string Library { get; set; }

    public string Name { get; set; }

    public string File { get; set; }
}

public static class GHelper
{
    public static string[] ValidTypes = {
        "void",
        "int",
        "string",
        "bool",
        "IntPtr",
        "double",
        "float",
        "char",
        "string[]",
        "uint"
    };
}

public class Param
{
    public bool Out;
    public string Type;
    public string Name;

    public Param(string linepart)
    {
        var split = linepart.Split(' ');
        var pos = 0;

        if (split.Length == 3)
        {
            Out = true;
            pos += 1;
        }

        Type = split[pos];
        Name = split[pos + 1];
    }

    public bool IsStruct()
    {
        return !GHelper.ValidTypes.Contains(Type);
    }
}

public class Method
{
    public string ReturnType;
    public string Name;
    public List<Param> Params;
    public bool CustomMethod;

    public Method(string line)
    {
        var basesplit = line.Split('(');

        var nrsplit = basesplit[0].Split(' ').ToList();
        nrsplit.RemoveAll((obj) => string.IsNullOrWhiteSpace(obj));
        ReturnType = nrsplit[0];
        Name = nrsplit[1];

        Params = new List<Param>();
        var psplit = basesplit[1].Split(')')[0].Split(',');
        foreach (var ps in psplit)
            if (!string.IsNullOrWhiteSpace(ps))
                Params.Add(new Param(ps.Trim(' ')));

        CustomMethod = ReturnType == "string" || !GHelper.ValidTypes.Contains(ReturnType);
        if (!CustomMethod)
        {
            foreach (var p in Params)
            {
                if (p.IsStruct() && !p.Out)
                    CustomMethod = true;
            }
        }
    }

    private string GetParamsLine(int position)
    {
        string parms = "";

        foreach (var param in Params)
        {
            if (param.Out)
                parms += "out ";

            if (position == 0 || position == 1)
            {
                if (position == 0 && !param.Out && param.IsStruct())
                    parms += "IntPtr ";
                else
                    parms += param.Type + " ";
            }

            if (position == 2 && !param.Out && param.IsStruct())
                parms += "p";
            parms += param.Name;

            parms += ", ";
        }

        if (Params.Count > 0)
            parms = parms.Remove(parms.Length - 2);

        return parms;
    }

    public override string ToString()
    {
        string lines = "";

        lines += "[DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = \"" + Name + "\")]" + Environment.NewLine;
        lines += (CustomMethod ? "private" : "public") + " extern static " + (CustomMethod ? (((ReturnType == "string" || !GHelper.ValidTypes.Contains(ReturnType)) ? "IntPtr" : ReturnType) + " w") : ReturnType + " ") + Name + "(" + GetParamsLine(0) + ");" + Environment.NewLine;
        lines += Environment.NewLine;

        if (CustomMethod)
        {
            lines += "public static " + ReturnType + " " + Name + "(" + GetParamsLine(1) + ")" + Environment.NewLine;
            lines += "{" + Environment.NewLine;

            foreach (var parm in Params)
            {
                if (!parm.Out && parm.IsStruct())
                {
                    lines += "    IntPtr p" + parm.Name + " = Marshal.AllocHGlobal(Marshal.SizeOf(" + parm.Name + "));" + Environment.NewLine;
                    lines += "    Marshal.StructureToPtr(" + parm.Name + ", p" + parm.Name + ", true);" + Environment.NewLine;
                }
            }

            lines += "    ";

            if (ReturnType != "void")
                lines += "var ret = ";

            if (ReturnType == "string")
                lines += "WrapperHelper.GetString(";
            else if (!GHelper.ValidTypes.Contains(ReturnType))
                lines += "(" + ReturnType + ")Marshal.PtrToStructure(";

            lines += "w" + Name + "(" + GetParamsLine(2) + ")";

            if (ReturnType == "string")
                lines += ")";
            else if (!GHelper.ValidTypes.Contains(ReturnType))
                lines += ", typeof(" + ReturnType + "))";

            lines += ";" + Environment.NewLine;

            foreach (var parm in Params)
            {
                if (!parm.Out && parm.IsStruct())
                {
                    lines += "    Marshal.FreeHGlobal(p" + parm.Name + ");" + Environment.NewLine;
                }
            }

            if (ReturnType != "void")
                lines += "    return ret;" + Environment.NewLine;

            lines += "}" + Environment.NewLine;
            lines += Environment.NewLine;
        }

        return lines;
    }
}
#>